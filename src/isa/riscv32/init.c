/***************************************************************************************
 * 版权声明：
 * 本代码版权归南京大学于子浩所有。
 * NEMU基于Mulan PSL v2许可发布。
 * 您可以根据Mulan PSL v2的条款和条件使用此软件。
 * 您可以在以下网址获取Mulan PSL v2的副本：
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * 此软件按“原样”提供，不提供任何明示或暗示的担保，
 * 包括但不限于适销性、特定用途的适用性和非侵权性。
 *
 * 有关更多详细信息，请参阅Mulan PSL v2。
 ***************************************************************************************/

#include <isa.h>
#include <memory/paddr.h>

// 这与uint8_t类型不一致，但由于我们不直接访问数组，所以这样做是可以的
static const uint32_t img[] = {
    // Todo
    /*
    0x20000097, // auipc x6, 1: 将当前 PC 加上 131072 并将结果存储在寄存器 x1 中
    0x00028823, // sb  zero,16(t0): 将寄存器 zero 的值（值为 0）存储到地址为当前 PC 加上 16 的内存位置中
    0x0102c503, // lbu a0,16(t0): 将地址为当前 PC 加上 16 的内存位置中的字节加载到寄存器 a0 中
    0x00100073, // ebreak (used as nemu_trap): 触发 NemU 中断指令，通常用于中断处理
    0xdeadbeef, // some data: 一些数据，可能用于测试或其他目的的占位符数据
    */
    
	0x810002b7,  // lui x5, 4096  将十六进制数 0x80000 的高 20 位加载到寄存器 t0 中，而低 12 位被填充为 0
	0x0002a023,  // sw  zero,0(t0)  将零寄存器中的值（即 0）存储到内存中，存储地址由寄存器 t0 中的值指定
	0x0002a503,  // lw  a0,0(t0)    从内存中加载一个字（32 位数据）到寄存器 a0 中，加载的内存地址由寄存器 t0 中的值指定
	0x00100073,  // ebreak (used as nemu_trap)
};

// 重启函数
static void restart()
{
  /* 设置初始程序计数器。 */
  cpu.pc = RESET_VECTOR;

  /* 零寄存器始终为0。 */
  cpu.gpr[0] = 0;
}

// 初始化ISA
void init_isa()
{
  /* 加载内置镜像 */
  // 将预先定义的指令数组 img 复制到内存中的指定位置
  memcpy(guest_to_host(RESET_VECTOR), img, sizeof(img));

  /* 初始化这个虚拟计算机系统。 */
  // src/isa/mips32/init.c
  restart();
}

